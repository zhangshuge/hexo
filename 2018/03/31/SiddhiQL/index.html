<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="SiddhiQL," />










<meta name="description" content="&amp;ensp;&amp;ensp;Siddhi是一个轻量级的，简单的开源的复杂事件流程引擎。它使用类SQL的语言描述事件流任务，可以很好的支撑开发一个可扩展的，可配置的流式任务执行引擎。https://docs.wso2.com/display/CEP410/Inbuilt+Functions#InbuiltFunctions-ifThenElseifThenElse&amp;ensp;&amp;ensp;Siddhi支持">
<meta name="keywords" content="SiddhiQL">
<meta property="og:type" content="article">
<meta property="og:title" content="SiddhiQL">
<meta property="og:url" content="https://zhangshuge.github.io/2018/03/31/SiddhiQL/index.html">
<meta property="og:site_name" content="卐 张墨辰 Ψ">
<meta property="og:description" content="&amp;ensp;&amp;ensp;Siddhi是一个轻量级的，简单的开源的复杂事件流程引擎。它使用类SQL的语言描述事件流任务，可以很好的支撑开发一个可扩展的，可配置的流式任务执行引擎。https://docs.wso2.com/display/CEP410/Inbuilt+Functions#InbuiltFunctions-ifThenElseifThenElse&amp;ensp;&amp;ensp;Siddhi支持">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-03-31T10:09:52.777Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SiddhiQL">
<meta name="twitter:description" content="&amp;ensp;&amp;ensp;Siddhi是一个轻量级的，简单的开源的复杂事件流程引擎。它使用类SQL的语言描述事件流任务，可以很好的支撑开发一个可扩展的，可配置的流式任务执行引擎。https://docs.wso2.com/display/CEP410/Inbuilt+Functions#InbuiltFunctions-ifThenElseifThenElse&amp;ensp;&amp;ensp;Siddhi支持">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhangshuge.github.io/2018/03/31/SiddhiQL/"/>





  <title>SiddhiQL | 卐 张墨辰 Ψ</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">卐 张墨辰 Ψ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">智慧的人受到表扬时，字字反省。愚蠢的人受到批评时，句句反驳。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhangshuge.github.io/2018/03/31/SiddhiQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张舒歌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://example.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卐 张墨辰 Ψ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SiddhiQL</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T18:04:35+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index">
                    <span itemprop="name">BigData</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&ensp;&ensp;Siddhi是一个轻量级的，简单的开源的复杂事件流程引擎。它使用类SQL的语言描述事件流任务，可以很好的支撑开发一个可扩展的，可配置的流式任务执行引擎。<a href="https://docs.wso2.com/display/CEP410/Inbuilt+Functions#InbuiltFunctions-ifThenElseifThenElse" target="_blank" rel="noopener">https://docs.wso2.com/display/CEP410/Inbuilt+Functions#InbuiltFunctions-ifThenElseifThenElse</a><br>&ensp;&ensp;Siddhi支持对于流式数据的类 SQL 的查询，SQL 式的 query 通过 complier 翻译成 Java 代码。 当一条数据流或多条数据流流入时，Siddhi Core 会实时的 check 当前数据流是否满足定义的 query，如果满足则触发 Callback 执行相应的逻辑。</p>
<h2 id="siddhi查询语言介绍"><a href="#siddhi查询语言介绍" class="headerlink" title="siddhi查询语言介绍"></a>siddhi查询语言介绍</h2><p>&ensp;&ensp;siddhi查询语言（siddhiql）旨在处理事件流以识别复杂的事件发生。下表提供了siddhi查询语言中几个术语的定义。</p>
<table>
<thead>
<tr>
<th style="text-align:left">术语</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Event Stream Definition</td>
<td style="text-align:left">定义事件流。一个事件流有一个唯一的名字和一组赋予特定类型的属性，其中唯一可识别的名字定义了它的模式。</td>
</tr>
<tr>
<td style="text-align:left">Event</td>
<td style="text-align:left">一个事件只与一个事件流关联，并且该流的所有事件都具有一组相同的属性，这些属性被分配了特定的类型（或相同的模式）。 事件包含时间戳和根据模式的属性值。</td>
</tr>
<tr>
<td style="text-align:left">Attribute</td>
<td style="text-align:left">一个属性在事件流中具有唯一的名称。属性类型可以是字符串，int，long，float，double，bool或object。</td>
</tr>
<tr>
<td style="text-align:left">Event Table</td>
<td style="text-align:left">存储数据的结构化表示，允许存储的数据在运行时被访问和操作。</td>
</tr>
<tr>
<td style="text-align:left">Event Stream</td>
<td style="text-align:left">一系列按时排序的事件。</td>
</tr>
<tr>
<td style="text-align:left">Partition</td>
<td style="text-align:left">一个逻辑容器，它根据预定义的分离规则处理查询的一个子集。</td>
</tr>
<tr>
<td style="text-align:left">Query</td>
<td style="text-align:left">通过组合现有流来推导新流的逻辑结构。查询包含一个或多个输入流，修改这些输入流的处理程序以及发布其输出事件的输出流。</td>
</tr>
</tbody>
</table>
<p>siddhi有以下语言结构：</p>
<ul>
<li>Event Stream Definitions</li>
<li>Event Table Definitions</li>
<li>Partitions</li>
<li>Queries</li>
</ul>
<p>siddhi的执行逻辑可以作为一个执行计划组合在一起，所有上述的语言结构可以写成一个执行计划中的脚本。<br>每个构造应该用分号（;）分隔。</p>
<h3 id="Event-Stream"><a href="#Event-Stream" class="headerlink" title="Event Stream"></a>Event Stream</h3><p>&ensp;&ensp;事件流是具有定义的模式的事件序列。可以使用查询导入和处理一个或多个事件流以识别复杂的事件条件，并且创建新的事件流以通知查询响应.<br>&ensp;&ensp;将具有定义的模式的事件的类型序列，一个或多个事件流可以被查询消耗和操纵以便识别复杂的事件条件，并且可以发射新的事件流以通知查询响应。</p>
<h3 id="Event-Stream-Definition"><a href="#Event-Stream-Definition" class="headerlink" title="Event Stream Definition"></a>Event Stream Definition</h3><p>定义了事件流模式。一个事件流定义包含一个唯一的名字和一组赋予特定类型的属性，并在流中有唯一可识别的名字。</p>
<blockquote>
<p>define stream &lt;stream name\&gt; (&lt;attribute name&gt; &lt;attribute type&gt;, &lt;attribute name&gt; &lt;attribute type&gt;, … );</p>
</blockquote>
<p>Eg.可以使用以下属性创建一个名为tempstream的流，如下所示。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名称</th>
<th style="text-align:left">属性类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">deviceID</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">roomNo</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">temp</td>
<td style="text-align:left">double</td>
</tr>
</tbody>
</table>
<blockquote>
<p>define stream TempStream (deviceID long, roomNo int, temp double);</p>
</blockquote>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p>每个siddhi查询都可以使用一个或多个事件流，并从中创建一个新的事件流。所有的查询都包含一个输入部分和一个输出部分。有些还包含投影部分。所有三个部分的简单查询如下。</p>
<blockquote>
<p>from &lt;input stream name&gt;<br>select &lt;attribute name&gt;, &lt;attribute name&gt;, …<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>Eg.</p>
<blockquote>
<p>from bankSummaryInfo#window.timeBatch(5 sec)<br>select idc,<br>  &ensp;&ensp;sum(bankCount) as totalBankCount,<br>    &ensp;&ensp;convert(sum(bankChannelTotalTime),’double’)/convert(sum(bankCount),’double’) as bankChannelAvgTime,<br>    &ensp;&ensp;convert(sum(bankBizSuccessCount),’double’)/convert(sum(bankCount),’double’) as bankBizPercent,<br>    &ensp;&ensp;convert(sum(bankSysSuccessCount),’double’)/convert(sum(bankCount),’double’) as bankSysPercent,<br>    &ensp;&ensp;convert(sum(bankChannelSysSuccessCount),’double’)/con vert(sum(bankCount),’double’) as bankChannelSysPercent,<br>    &ensp;&ensp;convert(sum(bankTotalTime),’double’)/convert(sum(bankCount),’double’) as bankAvgTime<br>insert into defaultBankSummaryInfo;</p>
</blockquote>
<h4 id="Inferred-Stream"><a href="#Inferred-Stream" class="headerlink" title="Inferred Stream:"></a>Inferred Stream:</h4><p>&ensp;&ensp;这里的defaultBankSummaryInfo是一个推断的流，即defaultBankSummaryInfo可以用作另一个查询的输入查询而不显式定义其事件流定义。因为它的事件流定义是从上面的查询中推断出来的。</p>
<h4 id="Query-Projection"><a href="#Query-Projection" class="headerlink" title="Query Projection"></a>Query Projection</h4><p>siddhiql支持以下查询投影。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Introducing the default value<br>（采用默认值）</td>
<td style="text-align:left">这涉及到添加默认值并使用as将其分配给一个属性。<br>  <blockquote>from TempStream<br>select roomNo, temp, ‘C’ as scale<br>insert into RoomTempStream;</blockquote></td>
</tr>
<tr>
<td style="text-align:left">Renaming attributes<br>(重命名属性)</td>
<td style="text-align:left">这涉及到从输入流中选择属性并将其插入具有不同名称的输出流中。<br><blockquote>from TempStream<br>select roomNo as roomNumber, temp as temperature<br>insert into RoomTempStream;</blockquote></td>
</tr>
<tr>
<td style="text-align:left">Selecting all attributes for projection<br>(选择所有的投影属性)</td>
<td style="text-align:left">这包括选择要插入到输出流中的输入流中的所有属性。 这可以通过使用星号（*）或通过省略选择语句来完成。<br>使用以下查询之一来选择TempStream流中的所有属性。<br> <blockquote>from TempStream <br>select ﹡  <br>insert into NewTempStream;</blockquote>or<blockquote>from TempStream<br>insert into NewTempStream;</blockquote></td>
</tr>
<tr>
<td style="text-align:left">Selecting required objects for projection<br>（选择投影所需的对）</td>
<td style="text-align:left">这包括只选择输入流中的一些属性插入到输出流中。<br>Eg.以下查询仅从TempStream流中选择roomNo和temp属性。<br><blockquote>from TempStream<br>select roomNo, temp<br>insert into RoomTempStream;</blockquote></td>
</tr>
<tr>
<td style="text-align:left">Using mathematical and logical expressions<br>(使用数学和逻辑表达式)</td>
<td style="text-align:left">这涉及使用具有数学和逻辑表达式的属性到下面给出的优先顺序，并使用as将它们分配给输出属性。<br><p>Operator precedence</p><br><table border="1"><tr><th>Operator</th><th>distribution</th><th>example</th></tr><tr><td>()</td><td>范围</td><td>(cost + tax) * 0.05</td></tr><tr><td> IS NULL</td><td>判断是否为空</td><td>deviceID is null</td></tr><tr><td>NOT</td><td>逻辑否</td><td>not (price &gt; 10)</td></tr><tr><td>+&ensp;-&ensp;﹡&ensp;/&ensp; % </td><td>加、减乘、除、取模</td><td>temp ﹡ 9/5 + 32</td></tr><tr><td>&lt;   &lt;=   &gt;   &gt;=</td><td>比较：小于，大于，等于，大于，小于等于</td><td>totalCost &gt;= price ﹡ quantity</td></tr><tr><td>==   != </td><td>比较：相等，不相等</td><td>    totalCost &gt;= price ﹡ quantity</td></tr><tr><td>IN</td><td>包含在表中</td><td>roomNo in ServerRoomsTable</td></tr><tr><td>AND</td><td>逻辑与</td><td>temp &lt; 40 and (humidity &lt; 40 or humidity &gt;= 60)</td></tr><tr><td>OR</td><td>逻辑与</td><td>temp &lt; 40 and (humidity &lt; 40 or humidity &gt;= 60)</td></tr></table>Eg.<br><blockquote>from TempStream<br>select roomNo, temp ﹡ 9/5 + 32 as temp, ‘F’ as scale, roomNo &gt;= 100 and roomNo &lt; 110 as isServerRoom<br>insert into RoomTempStream;</blockquote></td>
</tr>
</tbody>
</table>
<h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>一个函数需要零个，一个或多个函数参数并产生一个结果值。</p>
<h4 id="Function-parameters"><a href="#Function-parameters" class="headerlink" title="Function parameters"></a>Function parameters</h4><p>函数参数可以是属性（int，long，float，double，string，bool，object），其他函数的结果，数学或逻辑表达式的结果或时间参数。时间是一个特殊的参数，我们可以使用时间值定义为int，单位类型定义为&lt;int&gt; &lt;unit&gt;。 以下是受支持的单位类型，执行时间将以毫秒为单位将其表达式作为长整型值返回。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Unit</th>
<th style="text-align:left">Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Year</td>
<td style="text-align:left">year &brvbar; yuears</td>
</tr>
<tr>
<td style="text-align:left">Month</td>
<td style="text-align:left">month &brvbar; month</td>
</tr>
<tr>
<td style="text-align:left">Week</td>
<td style="text-align:left">week &brvbar; weeks</td>
</tr>
<tr>
<td style="text-align:left">Day</td>
<td style="text-align:left">day   &brvbar; days</td>
</tr>
<tr>
<td style="text-align:left">Hour</td>
<td style="text-align:left">hour  &brvbar; hours</td>
</tr>
<tr>
<td style="text-align:left">Minutes</td>
<td style="text-align:left">minute &brvbar; minutes &brvbar; min</td>
</tr>
<tr>
<td style="text-align:left">Seconds</td>
<td style="text-align:left">second &brvbar; seconds &brvbar; sec</td>
</tr>
<tr>
<td style="text-align:left">Milliseconds</td>
<td style="text-align:left">millisecond &brvbar; milliseconds</td>
</tr>
</tbody>
</table>
<p>Eg.通过1小时25分钟测试功能。</p>
<blockquote>
<p>test(1 hour 25 min)</p>
</blockquote>
<p>函数，数学表达式和逻辑表达式可以以嵌套方式使用。</p>
<h4 id="Inbuilt-Functions"><a href="#Inbuilt-Functions" class="headerlink" title="Inbuilt Functions"></a>Inbuilt Functions</h4><p>siddhi支持以下内置功能。</p>
<ul>
<li>coalesce  合并<br>&lt;int|long|float|double|string|bool|object&gt; coalesce(&lt;int|long|float|double|string|bool|object&gt; arg1, &lt;int|long|float|double|string|bool|object&gt; arg2,.., &lt;int|long|float|double|string|bool|object&gt; argN)<ul>
<li>Extension Type：Function</li>
<li>Description：返回第一个非null输入参数的值。</li>
<li>Parameter: 这个函数接受一个或多个参数，它们都必须是相同类型的任何一种可用类型。</li>
<li>Return Type：返回类型将是第一个输入参数的类型</li>
<li>Examples：coalesce(‘123’, null, ‘789’) returns ‘123’. coalesce(null, 76, 567) returns 76. coalesce(null, null, null) returns null.</li>
</ul>
</li>
<li>convert   转换<br>&lt;int|long|float|double|string|bool&gt; convert(&lt;int|long|float|double|string|bool&gt;  toBeConverted, &lt;string&gt; convertedTo)<ul>
<li>Extension Type：Function</li>
<li>Description：根据转换后的参数转换第一输入参数。</li>
<li>Parameter: toBeConverted：用对象以外的类型转换参数。</li>
<li>Parameter: convertedTo: 一个字符串常量参数，表示使用以下字符串值之一的外部类型 : ‘int’, ‘long’, ‘float’, ‘double’, ‘string’, ‘bool’.</li>
<li>Return Type：返回类型将是由convertedto参数指定的类型。</li>
<li>Examples：convert(‘123’, ‘double’) returns 123.0. convert(45.9, ‘int’) returns 46. convert(true, ‘string’) returns ‘true’.</li>
</ul>
</li>
<li>instanceOfBoolean<br>&lt;bool&gt; instanceOfBoolean(&lt;int|long|float|double|string|bool|object&gt; arg)<ul>
<li>Extension Type: Function</li>
<li>Description：检查参数是否是布尔值的一个实例</li>
<li>Parameter: arg：要检查的参数。</li>
<li>Return Type：返回布尔型，如果参数是布尔型的实例，则返回true，否则返回false。</li>
<li>Examples：instanceOfBoolean(123) returns false. instanceOfBoolean(true) returns true. instanceOfBoolean(false) returns true.</li>
</ul>
</li>
<li>instanceOfDouble<br>&lt;bool&gt;  instanceOfDouble(&lt;int|long|float|double|string|bool|object&gt;  arg)<ul>
<li>Extension Type: Function</li>
<li>Description：检查参数是否是double的一个实例。</li>
<li>Parameter: arg：要检查的参数。</li>
<li>Return Type：返回bool，如果参数是double的实例，则返回true，否则返回false。</li>
<li>Examples：instanceOfDouble(123) returns false. instanceOfDouble(56.45) returns true. instanceOfDouble(false) returns false.</li>
</ul>
</li>
<li>instanceOfFloat<br>&lt;bool&gt;  instanceOfFloat(&lt;int|long|float|double|string|bool|object&gt;  arg)<ul>
<li>Extension Type: Function</li>
<li>Description：检查参数是否是float的一个实例。</li>
<li>Parameter: arg：要检查的参数。</li>
<li>Return Type：返回bool，如果参数是float的实例，则返回true，否则返回false。</li>
<li>Examples： instanceOfFloat(123) returns false. instanceOfFloat(56.45) returns false. instanceOfFloat(56.45f) returns true.</li>
</ul>
</li>
<li>instanceOfInteger<br>&lt;bool&gt; instanceOfInteger(&lt;int|long|float|double|string|bool|object&gt; arg)<ul>
<li>Extension Type: Function</li>
<li>Description：检查参数是否是整数的一个实例。</li>
<li>Parameter: arg：要检查的参数</li>
<li>Return Type: 返回bool，如果参数是integer的一个实例，则返回true，否则返回false。</li>
<li>Examples：instanceOfLong(123) returns false. instanceOfLong(5667l) returns true. instanceOfLong(56.67) returns false.</li>
</ul>
</li>
<li>instanceOfString<br>&lt;bool&gt; instanceOfString(&lt;int|long|float|double|string|bool|object&gt; arg)<ul>
<li>Extension Type: Function</li>
<li>Description：检查参数是否是字符串的一个实例。</li>
<li>Parameter: arg：要检查的参数</li>
<li>Return Type：返回bool，如果参数是字符串的实例，则返回true，否则返回false。</li>
<li>Examples：instanceOfString(‘test’) returns true. instanceOfString(‘5667’) returns true. instanceOfString(56.67) returns false.</li>
</ul>
</li>
<li><p>UUID<br>&lt;string&gt; UUID()</p>
<ul>
<li>Extension Type: Function</li>
<li>Description：生产一个UUID</li>
<li>Return Type：返回一个UUID字符串</li>
<li>Examples：UUID() returns a34eec40-32c2-44fe-8075-7f4fde2e2dd8.</li>
</ul>
</li>
<li><p>ifThenElse</p>
</li>
<li>maximum</li>
<li>minimum</li>
<li>cast</li>
</ul>
<p>Eg.将房间号转换为字符串并将消息ID引入每个事件</p>
<blockquote>
<p>from TempStream<br>select convert(roomNo, ‘string’) as roomNo, temp, UUID() as messageID<br>insert into RoomTempStream;</p>
</blockquote>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>过滤器可以与输入流一起使用，以根据给定的过滤条件过滤事件。过滤条件应该在输入流名称旁边的方括号中定义。</p>
<blockquote>
<p>from &lt;input stream name&gt;[&lt;filter condition&gt;]<br>select &lt;attribute name&gt;, &lt;attribute name&gt;, …<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>Eg.过滤温度大于40度的所有服务器房间。</p>
<blockquote>
<p>from TempStream [(roomNo &gt;= 100 and roomNo &lt; 110) and temp &gt; 40 ]<br>select roomNo, temp<br>insert into HighTempStream;</p>
</blockquote>
<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>Windows允许基于来自输入事件流的标准来捕获事件子集以用于计算，可以使用“#window”在输入流旁边定义它们。 前缀，每个输入流最多只能有一个窗口，如下所示。</p>
<blockquote>
<p>from &lt;input stream name&gt;[&lt;filter condition&gt;]#window.&lt;window name&gt;(&lt;parameter&gt;, &lt;parameter&gt;, … )<br>select &lt;attribute name&gt;, &lt;attribute name&gt;, …<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>Windows为其使用的每个事件发出两个事件：它们是当前事件和过期事件。 当新事件到达窗口时，窗口发出当前事件，并且每当窗口中的事件基于该窗口条件到期时发出过期事件。</p>
<h5 id="Inbuilt-Windows"><a href="#Inbuilt-Windows" class="headerlink" title="Inbuilt Windows"></a>Inbuilt Windows</h5><p>siddhi支持以下内置窗口。</p>
<ul>
<li>time<br>&lt;event&gt; time(&lt;int|long|time&gt; windowTime)<ul>
<li>Extension Type: Window</li>
<li>Description：滑动时间窗口，其持有在上一个窗口时间段内到达的事件，并在每个事件到达和到期时得到更新。</li>
<li>Parameter: windowTime: 窗口应该容纳事件的滑动时间段。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples： time(20) for processing events arrived in last 20 milliseconds. time(2 min) for processing events arrived in last 2 minutes.</li>
</ul>
</li>
<li><p>timeBatch<br>&lt;event&gt; timeBatch(&lt;int|long|time&gt; windowTime)</p>
<ul>
<li>Extension Type：Window</li>
<li>Description：批量（翻滚）时间窗口，用于保存在窗口时间段之间到达的事件，并在每个窗口时间更新。</li>
<li>Parameter: windowTime：窗口应该保存事件的批处理时间段。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples: timeBatch(20) for processing events arrived every 20 milliseconds. timeBatch(2 min) for processing events arrived every 2 minutes.</li>
</ul>
</li>
<li><p>length<br>&lt;event&gt; length(&lt;int&gt; windowLength)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：滑动长度窗口，保存最后的窗口长度事件，并在每个事件到达和到期时得到更新。</li>
<li>Parameter: windowLength: 需要在滑动长度窗口中的事件的数量。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples： length(10) for processing last 10 events. length(200) for processing last 200 events.</li>
</ul>
</li>
<li><p>lengthBatch<br>&lt;event&gt; lengthBatch(&lt;int&gt; windowLength)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：批量（滚动）长度窗口，可以容纳窗口事件，并在每个窗口事件到达时更新。</li>
<li>Parameter: windowLength：对于窗口应该翻滚的事件数量。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples: lengthBatch(10) for processing 10 events as a batch. lengthBatch(200) for processing 200 events as a batch.</li>
</ul>
</li>
<li><p>externalTime<br>&lt;event&gt; time(&lt;long&gt; timestamp, &lt;int|long|time&gt; windowTime)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：基于外部时间的滑动时间窗口，其保持来自外部时间戳的最后一个窗口时间段期间到达的事件，并且在每个单调递增的时间戳上得到更新。</li>
<li>Parameter: timestamp：窗口确定为当前时间并将采取行动的时间，此参数的值应单调递增。</li>
<li>Parameter: windowTime: 窗口应该容纳事件的滑动时间段。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples： externalTime(eventTime,20) for processing events arrived in last 20 milliseconds from the eventTime. externalTime(eventTimestamp, 2 min) for processing events arrived in last 2 minutes from eventTimestamp.</li>
</ul>
</li>
<li><p>cron<br>&lt;event&gt; cron(&lt;string&gt; cronExpression)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：cron窗口会以时间重复的方式周期性的输出处理过的事件，这就是基于时间的流逝而触发的。</li>
<li>Parameter: cronExpression：代表时间表的cron表达式。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples： cron(‘<em>/5 </em> <em> </em> * ?’) will output processed events every 5 seconds.</li>
</ul>
</li>
<li><p>firstUnique<br>&lt;event&gt; firstUnique(&lt;string&gt; attribute)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：第一个唯一窗口处理器根据给定的唯一属性只保留唯一的第一个事件。</li>
<li>Parameter: attribute：应该检查唯一性的属性。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples：firstunique（ip）将返回每个唯一ip的第一个事件。</li>
</ul>
</li>
<li><p>unique<br>&lt;event&gt; unique(&lt;string&gt; attribute)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：独特的窗口处理器只根据给定的唯一属性保留唯一的最新事件。</li>
<li>Parameter: attribute：应该检查唯一性的属性。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples：unique（IP）将返回最新的事件到达每个独特的IP。</li>
</ul>
</li>
<li><p>sort<br>&lt;event&gt; sort(&lt;int&gt; windowLength)<br>&lt;event&gt; sort(&lt;int&gt; windowLength, &lt;string&gt; attribute, &lt;string&gt; order)<br>&lt;event&gt; sort(&lt;int&gt; windowLength, &lt;string&gt; attribute, &lt;string&gt; order, .. , &lt;string&gt; attributeN, &lt;string&gt; orderN)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：排序处理器将保持到windowlength事件，并按给定的顺序排序。</li>
<li>Parameter: windowLength：对于窗口应该翻滚的事件数量</li>
<li>Parameter: attribute：应该检查订单的属性。</li>
<li>Parameter: order：由“asc”或“desc”定义的属性的顺序。如果某个属性既不是“asc”也不是“desc”，那么order默认为“asc”。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples：sort(5, price, ‘asc’) 按升序排列按价格排序的事件. 因此，在任何时候，窗口都包含5个最低价格。</li>
</ul>
</li>
<li><p>frequent<br>&lt;event&gt; frequent(&lt;int&gt; eventCount)<br>&lt;event&gt; frequent(&lt;int&gt; eventCount, &lt;string&gt; attribute, .. , &lt;string&gt; attributeN)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：频繁的窗口处理器将返回给定属性最常出现的值的最新事件。这个窗口处理器的频率计算是基于misra-gries（Misra-Gries算法是频繁项挖掘中一个著名的算法）计算算法的。</li>
<li>Parameter: eventCount: 发送到流中的最频繁事件的数量</li>
<li>Parameter: attribute：属性来分组事件。如果没有给出属性，则将考虑事件的所有属性的连接。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples： frequent(2) 将返回2个最频繁的事件， frequent(2, cardNo) 将返回2个最新的事件与最频繁出现的卡号码。</li>
</ul>
</li>
<li><p>lossyFrequent<br>&lt;event&gt; lossyFrequent(&lt;double&gt; supportThreshold, &lt;double&gt; errorBound)<br>&lt;event&gt; lossyFrequent(&lt;double&gt; supportThreshold, &lt;double&gt; errorBound, &lt;string&gt; attribute, .. , &lt;string&gt; attributeN)</p>
<ul>
<li>Extension Type: Window</li>
<li>Description：有损频繁窗口处理器将识别并返回当前频率超过支持阈值的所有事件。该窗口处理器的频率计算基于有损计数算法。</li>
<li>Parameter: supportThreshold：支持阈值</li>
<li>Parameter: errorBound：错误界限值</li>
<li>Parameter: attribute：属性来分组事件。如果没有给出属性，则将考虑事件的所有属性的连接。</li>
<li>Return Type：返回当前和过期的事件。</li>
<li>Examples： lossyFrequent(0.1, 0.01)将返回当前频率超过0.1的所有事件，误差范围为0.01。lossyFrequent(0.3, 0.05, cardNo)将返回cardno属性频率超过0.3的所有事件，误差为0.05。</li>
</ul>
</li>
</ul>
<h4 id="Output-Event-Categories"><a href="#Output-Event-Categories" class="headerlink" title="Output Event Categories"></a>Output Event Categories</h4><p>窗口输出可以基于事件类别（即当前事件和过期事件）来操作，使用以下关键字和输出流来操纵输出。</p>
<ul>
<li>current events：将发出所有到达窗口的事件。这是默认的功能是没有指定事件类别。</li>
<li>expired events：将从窗口发出所有到期的事件。</li>
<li>all events：将从窗口发出所有到达和到期的事件。</li>
</ul>
<p>Eg.将流中的所有事件延迟1分钟。</p>
<blockquote>
<p>from TempStream#window.time(1 min)<br>select *<br>insert expired events into DelayedTempStream</p>
</blockquote>
<h4 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h4><p>可以在窗口中使用集合函数在定义的窗口内执行集合计算。</p>
<h4 id="Inbuilt-Aggregate-Functions"><a href="#Inbuilt-Aggregate-Functions" class="headerlink" title="Inbuilt Aggregate Functions"></a>Inbuilt Aggregate Functions</h4><p>siddhi支持以下内置聚合函数。</p>
<ul>
<li><p>sum<br>&lt;long|double&gt; sum(&lt;int|long|double|float&gt; arg)</p>
<ul>
<li>Extension Type：Aggregate Function (聚合函数)</li>
<li>Description：计算所有事件总和</li>
<li>Parameter: arg：需要总结的值</li>
<li>Return Type：如果输入参数类型为int或long，则返回long，如果输入参数类型为float或double，则返回double。</li>
<li>Examples：sum(20)为每个事件的到达和到期返回一个20的总和.sum(temp)根据每个事件的到达和到期返回所有临时属性的总和。</li>
</ul>
</li>
<li><p>avg<br>&lt;double&gt; avg(&lt;int|long|double|float&gt; arg)</p>
<ul>
<li>Extension Type: Aggregate Function</li>
<li>Description：计算所有事件的平均值。</li>
<li>Parameter: arg：需要平均的值。</li>
<li>Return Type：将计算的平均值作为双倍返回。</li>
<li>Examples：avg(temp)根据到达和到期时间返回所有事件的平均温度值。</li>
</ul>
</li>
<li><p>max<br>&lt;int|long|double|float&gt; max(&lt;int|long|double|float&gt; arg)</p>
<ul>
<li>Extension Type: Aggregate Function</li>
<li>Description：返回所有事件的最大值。</li>
<li>Parameter: arg：需要比较的值才能找到最大值</li>
<li>Return Type：返回与输入相同类型的最大值。</li>
<li>Examples：max(temp)根据其到达和到期时间返回所有事件记录的最大温度值</li>
</ul>
</li>
<li><p>min<br>&lt;int|long|double|float&gt; min(&lt;int|long|double|float&gt; arg)</p>
<ul>
<li>Extension Type: Aggregate Function</li>
<li>Description：返回所有事件的最小值</li>
<li>Parameter: arg：需要比较的值才能找到最小值</li>
<li>Return Type：返回与输入相同类型的最小值。</li>
<li>Examples：min(temp)根据到达和到期时间返回所有事件记录的最低温度值</li>
</ul>
</li>
<li><p>count<br>&lt;double&gt; stddev（&lt;int | long | double | float&gt; arg）</p>
<ul>
<li>Extension Type: Aggregate Function</li>
<li>Description：返回所有事件的计数。</li>
<li>Return Type：返回事件计数</li>
<li>Examples：count() 将返回所有事件的计数。</li>
</ul>
</li>
<li><p>stddev<br>&lt;double&gt; stddev(&lt;int|long|double|float&gt; arg)</p>
<ul>
<li>Extension Type: Aggregate Function</li>
<li>Description：返回所有事件的计算标准偏差。</li>
<li>Parameter: arg：在计算标准偏差时应该使用的数值</li>
<li>Return Type：将计算的标准偏差值作为双精度返回。</li>
<li>Examples：stddev(temp)返回所有基于到达和到期的事件的温度的计算标准偏差<br>Eg.通知所有活动到达和到期的所有房间的平均温度基于在过去10分钟到达的所有事件。<blockquote>
<p>from TempStream#window.time(10 min)<br>select avg(temp) as avgTemp, roomNo, deviceID<br>insert all events into AvgTempStream;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h4><p>group by允许我们根据属性对group进行分组。<br>Eg.查找最近10分钟内每个房间和设备ID的平均温度。</p>
<blockquote>
<p>from TempStream#window.time(10 min)<br>select avg(temp) as avgTemp, roomNo, deviceID<br>group by roomNo, deviceID<br>insert into AvgTempStream;</p>
</blockquote>
<h4 id="Having"><a href="#Having" class="headerlink" title="Having"></a>Having</h4><p>允许我们在聚合之后和在选择器处理之后过滤事件。<br>Eg.查找最近10分钟内的每个房间的平均温度，并在超过30度时发出警报。</p>
<blockquote>
<p>from TempStream#window.time(10 min)<br>select avg(temp) as avgTemp, roomNo<br>group by roomNo<br>having avgTemp &gt; 30<br>insert into AlertStream;</p>
</blockquote>
<h4 id="Output-Rate-Limiting"><a href="#Output-Rate-Limiting" class="headerlink" title="Output Rate Limiting"></a>Output Rate Limiting</h4><p>输出速率限制允许查询根据指定的条件周期性地发送事件。<br>速率限制遵循以下语法。</p>
<blockquote>
<p>from &lt;input stream name&gt;…<br>select &lt;attribute name&gt;, &lt;attribute name&gt;, …<br>output ({&lt;output-type&gt;} every (&lt;time interval&gt;|&lt;event interval&gt; events) | snapshot every &lt;time interval&gt;)<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>使用“<output-type>”可以指定需要发出的事件数量，“first”，“last”和“all”是可指定为只发出第一个事件，最后一个事件，<br>或来自所到达事件的所有事件。如果关键字被省略，它将默认为“全部”发出所有事件。<br>用“<time interval="">”来定义周期性事件情感的时间间隔。<br>通过“<event interval="">”，可以指定需要到达的周期事件情感的事件数量。</event></time></output-type></p>
<h4 id="Based-on-number-of-events-根据事件数量"><a href="#Based-on-number-of-events-根据事件数量" class="headerlink" title="Based on number of events   根据事件数量"></a>Based on number of events   根据事件数量</h4><p>这里事件将在预定数量的事件到达时发出，当发射事件可以被指定为仅发出来自事件的第一事件，最后事件或所有事件时。<br>Eg.每10个事件发出一个传感器的最后温度事件</p>
<blockquote>
<p>from TempStream<br>select temp<br>group by deviceID<br>output last every 10 events<br>insert into LowRateTempStream;</p>
</blockquote>
<h4 id="Based-on-time-基于时间"><a href="#Based-on-time-基于时间" class="headerlink" title="Based on time  基于时间"></a>Based on time  基于时间</h4><p>这里事件将在每个预定义的时间间隔发射，当发射它可以被指定为仅发射来自事件的第一事件，最后事件或所有事件。<br>Eg.每10秒发出一次温度事件</p>
<blockquote>
<p>from TempStream<br>output every 10 sec<br>insert into LowRateTempStream;</p>
</blockquote>
<h4 id="Periodic-snapshot-定期快照"><a href="#Periodic-snapshot-定期快照" class="headerlink" title="Periodic snapshot   定期快照"></a>Periodic snapshot   定期快照</h4><p>这对于Windows最有效，当输入流作为窗口附加的快照速率限制时，将发出迄今为止到达的所有当前事件，在每个预定义的时间间隔内没有相应的过期事件，同时当没有窗口连接到输入时流只会在每个预定义的时间间隔内发出最后的当前事件。<br>Eg.以每秒5秒的时间窗口发出事件的快照。</p>
<blockquote>
<p>from TempStream#window.time(5 sec)<br>output snapshot every 1 sec<br>insert into SnapshotTempStream;</p>
</blockquote>
<h4 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h4><p>join允许两个事件流根据条件进行合并.这里每个流都应该与一个窗口相关联（如果没有窗口赋值＃window.length（0）被分配给输入事件流）。在加入过程中，基于给定的条件，每个流上的每个传入事件将与另一个输入事件流窗口中的所有事件匹配，并且对于所有匹配的事件对，将生成输出事件。<br>连接的语法如下所示:</p>
<blockquote>
<p>from &lt;input stream name&gt;[&lt;filter condition&gt;]#window.&lt;window name&gt;(&lt;parameter&gt;, … ) {unidirectional} {as &lt;reference&gt;}<br>        join &lt;input stream name&gt;#window.&lt;window name&gt;(&lt;parameter&gt;,  … ) {unidirectional} {as &lt;reference&gt;}<br>    on &lt;join condition&gt;<br>    within &lt;time gap&gt;<br>select &lt;attribute name&gt;, &lt;attribute name&gt;, …<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>与“在<join condition="">”siddhi只加入匹配条件的事件。<br>用“单向”关键字可以控制加入过程的触发。默认情况下，到达两个流的事件触发加入过程，并且在输入流上使用单向关键字时，只有到达该流的事件才会触发加入过程。请注意，我们不能对这两个输入流使用单向关键字（因为它等于默认行为，根本不使用单向关键字）。<br>与“在<time gap="">”加入过程相匹配的事件是在规定的时间间隔彼此。<br>当投影连接事件时，每个流的属性需要用流名称（例如<stream name="">。<attribute name="">）或引用ID（特别是当连接相同流的事件时）引用（例如<stream reference="" id="">。<attribute name="">），可以使用“select *”或者“select”语句本身，如果连接事件的所有属性都需要被投影，则这些语句本身可以被忽略，但是这些只能在两个流都没有具有相同名称的属性。<br>Eg.假定温度调节器每分钟更新一次。如果房间温度大于30度的所有房间都没有打开温度调节器，那么以下开关将会打开。</attribute></stream></attribute></stream></time></join></p>
<blockquote>
<p>define stream TempStream(deviceID long, roomNo int, temp double);<br><br>define stream RegulatorStream(deviceID long, roomNo int, isOn bool);<br><br>from TempStream[temp &gt; 30.0]#window.time(1 min) as T<br>  &ensp;join RegulatorStream[isOn == false]#window.length(1) as R<br>  &ensp;on T.roomNo == R.roomNo<br>select T.roomNo, R.deviceID, ‘start’ as action<br>insert into RegulatorActionStream;</p>
</blockquote>
<h4 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h4><p>模式允许事件流随时间相关，并根据事件到达的顺序检测事件模式。与模式可以有其他事件之间的事件符合模式条件。它将在内部创建状态机来跟踪匹配进程的状态。模式可以在多个输入流或相同的输入流上关联事件，因此每个匹配的输入事件需要被引用，以便它可以被访问用于未来的处理和输出生成。<br>模式的语法如下所示:</p>
<blockquote>
<p>from {every} &lt;input event reference&gt;=&lt;input stream name&gt;[&lt;filter condition&gt;] -&gt; {every} &lt;input event reference&gt;=&lt;input stream name&gt;[&lt;filter condition&gt;] -&gt; …<br>    &ensp;&ensp;within &lt;time gap&gt;<br>select &lt;input event reference&gt;.&lt;attribute name&gt;, &lt;input event reference&gt;.&lt;attribute name&gt;, …<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>输入流不能与窗口关联。<br>使用“ - &gt;”我们可以关联传入的事件到达，在匹配事件之间有零个或多个其他事件到达。<br>使用”&lt;input event reference&gt;=”匹配的事件可以被存储以备将来参考。<br>使用“within&lt;time gap&gt;”的模式将只与相互之间定义的时间间隔内的事件相匹配。<br>如果没有“every”关键字，模式只能匹配一次，恰当地使用“每个”关键字来触发事件到达时的模式匹配过程。<br>Eg.如果房间温度在10分钟内上升5度，则发出警报。</p>
<blockquote>
<p>from every( e1=TempStream ) -&gt; e2=TempStream[e1.roomNo==roomNo and (e1.temp + 5) &lt;= temp ]<br>    &ensp;&ensp;within 10 min<br>select e1.roomNo, e1.temp as initialTemp, e2.temp as finalTemp<br>insert into AlertStream;</p>
</blockquote>
<h4 id="Logical-Pattern-逻辑模式"><a href="#Logical-Pattern-逻辑模式" class="headerlink" title="Logical Pattern  逻辑模式"></a>Logical Pattern  逻辑模式</h4><p>模式不仅匹配按时间顺序到达的事件，还可以将具有逻辑关系的事件关联起来。<br>可以在“ - &gt;”之间使用“and”，“or”等关键词来说明逻辑关系。<br>“and” 可以匹配任何顺序的两个事件的发生<br>“or” 可以匹配来自任何输入流的事件的发生<br>Eg.当房间温度达到调节器上设置的温度时，提醒（只要调节器上设置的温度发生变化，模式匹配应该重新设置）。</p>
<blockquote>
<p>define stream TempStream(deviceID long, roomNo int, temp double);<br><br>define stream RegulatorStream(deviceID long, roomNo int, tempSet double);<br><br>from every( e1=RegulatorStream ) -&gt; e2=TempStream[e1.roomNo==roomNo and e1.tempSet &lt;= temp ] or e3=RegulatorStream[e1.roomNo==roomNo]<br><br>select e1.roomNo, e2.temp as roomTemp<br>having e3 is null<br>insert into AlertStream;</p>
</blockquote>
<h4 id="Counting-Pattern-计算模式"><a href="#Counting-Pattern-计算模式" class="headerlink" title="Counting Pattern  计算模式"></a>Counting Pattern  计算模式</h4><p>计数模式使我们能够根据相同的匹配条件匹配多个事件。使用以下后缀可以限制预期的事件数量。<br>With <1:4> 可以匹配1到4个时间<br>With <2:> 匹配2个或更多时间<br>with &lt;:5&gt; 最多匹配5个事件<br>With <5>  完全匹配5个事件<br>根据计数限制来引用事件的具体事件，方括号可以与数字和“last”关键字一起使用，例如e1 [3]将引用第三个事件，e1 [last]将引用最后一个事件和e1 [last  -  1]将引用匹配事件组的最后一个事件之前的事件。<br>Eg.得到两个调节器事件之间的温差。</5></2:></1:4></p>
<blockquote>
<p>define stream TempStream(deviceID long, roomNo int, temp double);<br> define stream RegulatorStream(deviceID long, roomNo int, tempSet double, isOn bool);<br>  from every( e1=RegulatorStream) -&gt; e2=TempStream[e1.roomNo==roomNo]<1:> -&gt; e3=RegulatorStream[e1.roomNo==roomNo]<br>select e1.roomNo, e2[0].temp - e2[last].temp as tempDiff<br>insert into TempDiffStream;</1:></p>
</blockquote>
<h4 id="Sequence-序列"><a href="#Sequence-序列" class="headerlink" title="Sequence  序列"></a>Sequence  序列</h4><p>序列允许事件流随时间相关，并根据事件到达的顺序检测事件序列。在序列中，在与序列条件匹配的事件之间不能有其他事件。它将在内部创建状态机来跟踪匹配进程的状态。序列可以关联多个输入流或相同输入流上的事件，因此每个匹配的输入事件都需要被引用，使得它可以被访问用于未来的处理和输出生成。<br>序列的语法如下所示:</p>
<blockquote>
<p>from {every} &lt;input event reference&gt;=&lt;input stream name&gt;[&lt;filter condition&gt;], &lt;input event reference&gt;=&lt;input stream name&gt;[&lt;filter condition&gt;]{+|*|?}, …<br>    within &lt;time gap&gt;<br>select &lt;input event reference&gt;.&lt;attribute name&gt;, &lt;input event reference&gt;.&lt;attribute name&gt;, …<br>insert into &lt;output stream name&gt;</p>
</blockquote>
<p>输入流不能与窗口关联：<br>With “,” 我们可以将即将到来的下一个到达的事件关联起来，在匹配事件之间没有其他事件到达。<br>With “&lt;input event reference&gt;=” 匹配的事件可以被存储以备将来参考。<br>With “within &lt;time gap&gt;” 该序列将仅与在彼此的定义的时间间隙内的事件相匹配。<br>Without “every” 关键字模式只能匹配一次，在每个事件到来时，使用开始处的“every”关键字来触发序列匹配过程。<br>Eg.如果两次连续的温度事件之间的温度升高超过1度，则应警惕。</p>
<blockquote>
<p>from every e1=TempStream, e2=TempStream[e1.temp + 1 &lt; temp ]<br>select e1.temp as initialTemp, e2.temp as finalTemp<br>insert into AlertStream;</p>
</blockquote>
<h4 id="Logical-Sequence-逻辑序列"><a href="#Logical-Sequence-逻辑序列" class="headerlink" title="Logical Sequence   逻辑序列"></a>Logical Sequence   逻辑序列</h4><p>序列不仅匹配按时间顺序到达的连续事件，而且还可以关联具有逻辑关系的事件。<br>“and”和“or”等关键词可以用于“，”之间，说明逻辑关系。<br>With “and” 两个事件发生的顺序是可以匹配的<br>With “or” 可以匹配来自任何输入流的事件的发生<br>Eg.通知温度和湿度事件发生在监管事件之后。</p>
<blockquote>
<p>define stream TempStream(deviceID long, temp double);<br>define stream HumidStream(deviceID long, humid double);<br>define stream RegulatorStream(deviceID long, isOn bool);<br>from every e1=RegulatorStream, e2=TempStream and e3=HumidStream<br>select e2.temp, e3.humid<br>insert into StateNotificationStream;</p>
</blockquote>
<h3 id="Counting-Sequence-计算序列"><a href="#Counting-Sequence-计算序列" class="headerlink" title="Counting Sequence 计算序列"></a>Counting Sequence 计算序列</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SiddhiQL/" rel="tag"># SiddhiQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/31/Superset/" rel="next" title="Superset">
                <i class="fa fa-chevron-left"></i> Superset
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/21/virtualenv/" rel="prev" title="virtualenv">
                virtualenv <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://example.com/avatar.png"
                alt="张舒歌" />
            
              <p class="site-author-name" itemprop="name">张舒歌</p>
              <p class="site-description motion-element" itemprop="description">天道酬勤、厚德载物</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#siddhi查询语言介绍"><span class="nav-number">1.</span> <span class="nav-text">siddhi查询语言介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Stream"><span class="nav-number">1.1.</span> <span class="nav-text">Event Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Stream-Definition"><span class="nav-number">1.2.</span> <span class="nav-text">Event Stream Definition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Query"><span class="nav-number">1.3.</span> <span class="nav-text">Query</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inferred-Stream"><span class="nav-number">1.3.1.</span> <span class="nav-text">Inferred Stream:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Query-Projection"><span class="nav-number">1.3.2.</span> <span class="nav-text">Query Projection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Functions"><span class="nav-number">1.3.3.</span> <span class="nav-text">Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-parameters"><span class="nav-number">1.3.4.</span> <span class="nav-text">Function parameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inbuilt-Functions"><span class="nav-number">1.3.5.</span> <span class="nav-text">Inbuilt Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter"><span class="nav-number">1.3.6.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Window"><span class="nav-number">1.3.7.</span> <span class="nav-text">Window</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Inbuilt-Windows"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">Inbuilt Windows</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Output-Event-Categories"><span class="nav-number">1.3.8.</span> <span class="nav-text">Output Event Categories</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Aggregate-Functions"><span class="nav-number">1.3.9.</span> <span class="nav-text">Aggregate Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inbuilt-Aggregate-Functions"><span class="nav-number">1.3.10.</span> <span class="nav-text">Inbuilt Aggregate Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Group-By"><span class="nav-number">1.3.11.</span> <span class="nav-text">Group By</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Having"><span class="nav-number">1.3.12.</span> <span class="nav-text">Having</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Output-Rate-Limiting"><span class="nav-number">1.3.13.</span> <span class="nav-text">Output Rate Limiting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Based-on-number-of-events-根据事件数量"><span class="nav-number">1.3.14.</span> <span class="nav-text">Based on number of events   根据事件数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Based-on-time-基于时间"><span class="nav-number">1.3.15.</span> <span class="nav-text">Based on time  基于时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Periodic-snapshot-定期快照"><span class="nav-number">1.3.16.</span> <span class="nav-text">Periodic snapshot   定期快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Joins"><span class="nav-number">1.3.17.</span> <span class="nav-text">Joins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pattern"><span class="nav-number">1.3.18.</span> <span class="nav-text">Pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Logical-Pattern-逻辑模式"><span class="nav-number">1.3.19.</span> <span class="nav-text">Logical Pattern  逻辑模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Counting-Pattern-计算模式"><span class="nav-number">1.3.20.</span> <span class="nav-text">Counting Pattern  计算模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sequence-序列"><span class="nav-number">1.3.21.</span> <span class="nav-text">Sequence  序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Logical-Sequence-逻辑序列"><span class="nav-number">1.3.22.</span> <span class="nav-text">Logical Sequence   逻辑序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Counting-Sequence-计算序列"><span class="nav-number">1.4.</span> <span class="nav-text">Counting Sequence 计算序列</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张舒歌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
