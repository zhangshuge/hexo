<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="storm," />










<meta name="description" content="Storm1、基本概念在storm的集群中有两种节点：  Nimbus:主节点（Mater Node）Nimbus负责在集群中分发代码，分配工作给机器，并且监控状态。 Supervisor:工作节点(Worker Node)每个工作节点上运行一个supervisor进程，supervisor会监听nimbus分配给那台机器的工作，根据需要启动或者关闭具体的worker进程。  每个worker进程">
<meta name="keywords" content="storm">
<meta property="og:type" content="article">
<meta property="og:title" content="storm">
<meta property="og:url" content="https://zhangshuge.github.io/2018/06/12/storm/index.html">
<meta property="og:site_name" content="卐 张墨辰 Ψ">
<meta property="og:description" content="Storm1、基本概念在storm的集群中有两种节点：  Nimbus:主节点（Mater Node）Nimbus负责在集群中分发代码，分配工作给机器，并且监控状态。 Supervisor:工作节点(Worker Node)每个工作节点上运行一个supervisor进程，supervisor会监听nimbus分配给那台机器的工作，根据需要启动或者关闭具体的worker进程。  每个worker进程">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/455bcbd79be710f1c6d0f571dc0895c8.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/f084adefc384f6d9b0941dba2f16855f.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/7142214dfcdee38b524d9d87a1639f0c.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/c6089a48f023c71a6133a55d9eb4f0a2.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/1158d324029134c0e9cc15d3865b9e57.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/afbe75105d45b4468dffa0ae8af34d5d.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/e1e783cdcd9be99de0af4488d1e17878.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/23cba149f511602b134dfc95fa5afac7.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/23cba149f511602b134dfc95fa5afac7.png">
<meta property="og:image" content="http://oy48q6kwm.bkt.clouddn.com/175f384b5f5abc26b816b032a715e025.png">
<meta property="og:image" content="c:/Users/zhangchi/Pictures/Saved%20Pictures/1534484566974.png">
<meta property="og:image" content="c:/Users/zhangchi/AppData/Local/Temp/1534486378370.png">
<meta property="og:image" content="c:/Users/zhangchi/Pictures/Saved%20Pictures/1534486615053.png">
<meta property="og:image" content="c:/Users/zhangchi/AppData/Local/Temp/1534486864083.png">
<meta property="og:updated_time" content="2019-01-17T16:33:56.468Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="storm">
<meta name="twitter:description" content="Storm1、基本概念在storm的集群中有两种节点：  Nimbus:主节点（Mater Node）Nimbus负责在集群中分发代码，分配工作给机器，并且监控状态。 Supervisor:工作节点(Worker Node)每个工作节点上运行一个supervisor进程，supervisor会监听nimbus分配给那台机器的工作，根据需要启动或者关闭具体的worker进程。  每个worker进程">
<meta name="twitter:image" content="http://oy48q6kwm.bkt.clouddn.com/455bcbd79be710f1c6d0f571dc0895c8.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhangshuge.github.io/2018/06/12/storm/"/>





  <title>storm | 卐 张墨辰 Ψ</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">卐 张墨辰 Ψ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">智慧的人受到表扬时，字字反省。愚蠢的人受到批评时，句句反驳。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhangshuge.github.io/2018/06/12/storm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张舒歌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://example.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卐 张墨辰 Ψ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">storm</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T19:35:06+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index">
                    <span itemprop="name">BigData</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>在storm的集群中有两种节点：</p>
<ul>
<li>Nimbus:主节点（Mater Node）<br>Nimbus负责在集群中分发代码，分配工作给机器，并且监控状态。</li>
<li>Supervisor:工作节点(Worker Node)<br>每个工作节点上运行一个supervisor进程，supervisor会监听nimbus分配给那台机器的工作，根据需要启动或者关闭具体的worker进程。</li>
</ul>
<p>每个worker进程执行一个具体的Topology，worker进程中的执行线程称为Executor,可以有一个或者多个。每个executor中又包含一个或者多个Task。Task是storm中最小的处理单元。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>概念</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Nimbus</td>
<td>负责资源分配和任务调度</td>
<td></td>
</tr>
<tr>
<td>Supervisor</td>
<td>负责接收Nimbus分配的任务，启动和停止属于自己管理的Worker进程</td>
<td></td>
</tr>
<tr>
<td>Worker</td>
<td>执行具体处理组件逻辑的进程,即执行Topology</td>
<td></td>
</tr>
<tr>
<td>Topology</td>
<td>一个实时计算应用程序逻辑被封装到Topology对象中，Topology拓扑会一直运行知道显示地杀死它</td>
<td></td>
</tr>
<tr>
<td>Executor</td>
<td>Storm0.8版本以后，Executor为Worker进程中的具体的物理线程，同一个Spout/Bolt的Task可能会共享一个物理线程，一个Executor中只能运行隶属于同一个Spout/Bolt的Task</td>
<td></td>
</tr>
<tr>
<td>Spout</td>
<td>在Topology中产生源数据流的组件。通常Spout获取数据源的数据（如Kafka、MQ等读取数据），然后调用nextTuple()函数，发射数据供Bolt消费。</td>
<td></td>
</tr>
<tr>
<td>Bolt</td>
<td>在Topology中接收spout发射的数据后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt在接收到消息后会调用execute()函数，用户可以在其中执行自己想要的操作</td>
<td></td>
</tr>
<tr>
<td>Tuple</td>
<td>消息传递的基本单元，即元组。</td>
<td></td>
</tr>
<tr>
<td>Task</td>
<td>每一个Spout/Bolt具体要做的工作，也是各个节点之间进行分组的单位</td>
<td></td>
</tr>
<tr>
<td>Stream</td>
<td>源源不断传递的Tuple组成的Stream</td>
<td></td>
</tr>
<tr>
<td>Stream分组</td>
<td>即消息的分区(partition)方法。storm提供若干种实用的分组方式，包括Shuffle、Fields、All、Global、None、Direct和Local or Shuffle等</td>
</tr>
</tbody>
</table>
<p>假设我们现在有一个Storm集群，一台nimbus和4台supervisor，默认情况下，一个supervisor可以启动4个worker。假设客户端提交了一个Topology需要4个worker来执行，<br><img src="http://oy48q6kwm.bkt.clouddn.com/455bcbd79be710f1c6d0f571dc0895c8.png" alt="storm1"><br>从上图可以看出并不是一个supervisor分配一个worker.这是因为nimbus是针对topology的任务分配，是针对worker来的。我们指定了topology需要4个woreker，nimbus会从已有的16个worker中选择四个worker，并不会平均分配。<strong>这里需要注意的是一个worker同时只能运行一个topology</strong>。如果此时再有另外一个topology提交，不管指定使用几个worker来执行，都会从剩下的12个worker中选择。</p>
<p>Nimbus和Supervisor之间的通信是依赖zookeeper完成的，并且nimbus和supervisor都是快速失败(fail-fast)和无状态的，所有的状态要么在zookeeper里面，要么在本地磁盘上。这也就意味着我们可以使用kill -9来杀死numbus和supervisor进程，然后再重启继续工作。<br><img src="http://oy48q6kwm.bkt.clouddn.com/f084adefc384f6d9b0941dba2f16855f.png" alt="storm2"></p>
<blockquote>
<p>小贴士：Storm中有一些术语(不是全部)，是按照气象术语来命名的。例如Storm是暴风雨，spout是龙卷风的意思，bolt是雷电的意思，nimbus是雨云的意思。</p>
</blockquote>
<h2 id="2、Storm组件"><a href="#2、Storm组件" class="headerlink" title="2、Storm组件"></a>2、Storm组件</h2><h3 id="Topology（拓扑）"><a href="#Topology（拓扑）" class="headerlink" title="Topology（拓扑）"></a>Topology（拓扑）</h3><p>一个topology中必须同时存在spout和bolt，而spout和bolt的数量可以是任意个。要提醒的是：Topology的组件目前只有Spout和Bolt，没有其他组件。所以以后提到一个Topology的组件的时候，其实也就是指的是Spout或者Bolt。</p>
<h3 id="Stream（流）"><a href="#Stream（流）" class="headerlink" title="Stream（流）"></a>Stream（流）</h3><p>我们已经知道Spout是从外部数据源中获取数据，以一定的格式将数据传递给Bolt处理。从Spout中源源不断的给Bolt传递数据，形成的这个数据通道我们称之为Stream。</p>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>tuple是stream中的最小组成单元，也叫元组。</p>
<p>最简单的一个topology模型。图中虚线的每一个小节点”-“就可以看作是一个tuple。<br><img src="http://oy48q6kwm.bkt.clouddn.com/7142214dfcdee38b524d9d87a1639f0c.png" alt="storm3"><br>spout可以将数据传递给多个bolt，bolt还能将数据传递给下一级bolt。这样的原因是，有的时候，我们对于数据的分析必须是一步一步的，后一步的分析必须建立在之前分析的基础上。<br><img src="http://oy48q6kwm.bkt.clouddn.com/c6089a48f023c71a6133a55d9eb4f0a2.png" alt="storm5"><br>Stream都是由Tuple组成的，而Tuple是有数据格式的，<strong>在同一个流中,Tuple的数据格式应该都是一样的；不同流中的数据格式可能相同，也可能不同.</strong></p>
<p>一个spout可以发射给多个bolt数据，同样一个bolt也可以接收多个spout发射的数据。<br><img src="http://oy48q6kwm.bkt.clouddn.com/1158d324029134c0e9cc15d3865b9e57.png" alt="复杂的topology"><br>在storm中，spout和bolt、bolt与bolt之间的数据流向，将整合topology串起来了行程了一个DAG(有向无环图)。**DAG的意思就是数据流是有方向的，但不能形成一个环状。如果形成了一个环状，那么意味着Bolt中的数据还可能传给Spout，spout又要传递给Bolt。这就形成了一个死循环，Stream中的一个数据(Tuple)永远也没办法处理完。下图中的两条红线都是不允许的。<br><img src="http://oy48q6kwm.bkt.clouddn.com/afbe75105d45b4468dffa0ae8af34d5d.png" alt="storm有向无环图"></p>
<h2 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h2><h3 id="下载安装包上传至服务器http-storm-apache-org-downloads-html"><a href="#下载安装包上传至服务器http-storm-apache-org-downloads-html" class="headerlink" title="下载安装包上传至服务器http://storm.apache.org/downloads.html"></a>下载安装包上传至服务器<a href="http://storm.apache.org/downloads.html" target="_blank" rel="noopener">http://storm.apache.org/downloads.html</a></h3><h3 id="分配好资源"><a href="#分配好资源" class="headerlink" title="分配好资源"></a>分配好资源</h3><p>ui:172.16.10.22<br>nimbus:172.16.10.22<br>supervisor1:172.16.10.23<br>supervisor2:172.16.10.24<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tools</span><br><span class="line">tar -xzvf apache-storm-1.1.0.tar.gz</span><br><span class="line">cd /tools/apache-storm-1.1.0/conf</span><br><span class="line">vim storm.yml</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p># Licensed to the Apache Software Foundation (ASF) under one<br># or more contributor license agreements.  See the NOTICE file<br># distributed with this work for additional information<br># regarding copyright ownership.  The ASF licenses this file<br># to you under the Apache License, Version 2.0 (the<br># “License”); you may not use this file except in compliance<br># with the License.  You may obtain a copy of the License at<br>#<br># <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">http://www.apache.org/licenses/LICENSE-2.0</a><br>#<br># Unless required by applicable law or agreed to in writing, software<br># distributed under the License is distributed on an “AS IS” BASIS,<br># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br># See the License for the specific language governing permissions and<br># limitations under the License.</p>
<p>########### These MUST be filled in for a storm configuration<br>storm.zookeeper.servers:<br>&nbsp;&nbsp;&nbsp;&nbsp;- “172.16.1.43”<br>&nbsp;&nbsp;&nbsp;&nbsp;- “172.16.1.62”<br>&nbsp;&nbsp;&nbsp;&nbsp;- “172.16.1.64”</p>
<p>#     - “server2”<br>nimbus.seeds: [“172.16.10.22”]<br>supervisor.slots.ports:<br>&nbsp;&nbsp;&nbsp;&nbsp;- 6700<br>&nbsp;&nbsp;&nbsp;&nbsp;- 6701<br>&nbsp;&nbsp;&nbsp;&nbsp;- 6702<br>&nbsp;&nbsp;&nbsp;&nbsp;- 6703</p>
<p>#<br># ##### These may optionally be filled in:<br>#<br>## List of custom serializations<br># topology.kryo.register:<br>#     - org.mycompany.MyType<br>#     - org.mycompany.MyType2: org.mycompany.MyType2Serializer<br>#<br>## List of custom kryo decorators<br># topology.kryo.decorators:<br>#     - org.mycompany.MyDecorator<br>#<br>## Locations of the drpc servers<br># drpc.servers:<br>#     - “server1”<br>#     - “server2”</p>
<p>## Metrics Consumers<br>## max.retain.metric.tuples<br>## - task queue will be unbounded when max.retain.metric.tuples is equal or less than 0.<br>## whitelist / blacklist<br>## - when none of configuration for metric filter are specified, it’ll be treated as ‘pass all’.<br>## - you need to specify either whitelist or blacklist, or none of them. You can’t specify both of them.<br>## - you can specify multiple whitelist / blacklist with regular expression<br>## expandMapType: expand metric with map type as value to multiple metrics<br>## - set to true when you would like to apply filter to expanded metrics<br>## - default value is false which is backward compatible value<br>## metricNameSeparator: separator between origin metric name and key of entry from map<br>## - only effective when expandMapType is set to true<br># topology.metrics.consumer.register:<br>#   - class: “org.apache.storm.metric.LoggingMetricsConsumer”<br>#     max.retain.metric.tuples: 100<br>#     parallelism.hint: 1<br>#   - class: “org.mycompany.MyMetricsConsumer”<br>#     max.retain.metric.tuples: 100<br>#     whitelist:<br>#       - “execute.*”<br>#       - “^__complete-latency$”<br>#     parallelism.hint: 1<br>#     argument:<br>#       - endpoint: “metrics-collector.mycompany.org”<br>#     expandMapType: true<br>#     metricNameSeparator: “.”</p>
<p>## Cluster Metrics Consumers<br># storm.cluster.metrics.consumer.register:<br>#   - class: “org.apache.storm.metric.LoggingClusterMetricsConsumer”<br>#   - class: “org.mycompany.MyMetricsConsumer”<br>#     argument:<br>#       - endpoint: “metrics-collector.mycompany.org”<br>#<br># storm.cluster.metrics.consumer.publish.interval.secs: 60</p>
<p>storm.local.dir: “/data/storm/data”<br>ui.port: 9001</p>
</blockquote>
<p>172.16.10.22、172.16.10.23、172.16.10.24每个节点的配置保持一直，另外需在给两个supervisor节点加上JMX监控。需要在storm.yaml文件中加入</p>
<blockquote>
<p>supervisor.childopts: -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=9998</p>
</blockquote>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>172.16.10.22</p>
<ul>
<li>nohup /tools/apache-storm-1.1.0/bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;</li>
<li>nohup /tools/apache-storm-1.1.0/bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;</li>
<li>nohup /tools/apache-storm-1.1.0/bin/storm logviewer &gt;/dev/null 2&gt;&amp;1 &amp;</li>
</ul>
<p><img src="http://oy48q6kwm.bkt.clouddn.com/e1e783cdcd9be99de0af4488d1e17878.png" alt="nimbus"> </p>
<p>core是UI进程、nimbus、logviewer进程已经都起来了。</p>
<p>172.16.10.23</p>
<ul>
<li>nohup /tools/apache-storm-1.1.0/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;</li>
<li>nohup /tools/apache-storm-1.1.0/bin/storm logviewer &gt;/dev/null 2&gt;&amp;1 &amp;</li>
</ul>
<p><img src="http://oy48q6kwm.bkt.clouddn.com/23cba149f511602b134dfc95fa5afac7.png" alt="supervisor"><br>supervisor进程已经启动。</p>
<p>172.16.10.24</p>
<ul>
<li>nohup /tools/apache-storm-1.1.0/bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;</li>
<li>nohup /tools/apache-storm-1.1.0/bin/storm logviewer &gt;/dev/null 2&gt;&amp;1 &amp;</li>
</ul>
<p><img src="http://oy48q6kwm.bkt.clouddn.com/23cba149f511602b134dfc95fa5afac7.png" alt="supervisor2"><br>supervisor进程已经启动。</p>
<h2 id="4、开发"><a href="#4、开发" class="headerlink" title="4、开发"></a>4、开发</h2><h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>在maven工程的pom.xml中引入storm依赖包。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.storm/storm-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>storm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>创建topology<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nucc.channel.govern.demo.storm.topology;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.spout.SpoutOutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichSpout;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Values;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.utils.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 拓扑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhangchi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: zhangchi@nucc.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span>: 2018/5/5 22:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormTopology</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Map conf;</span><br><span class="line">        <span class="keyword">private</span> TopologyContext topologyContext;</span><br><span class="line">        <span class="keyword">private</span> SpoutOutputCollector spoutOutputCollector;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化方法，用于创建数据源。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map                  配置属性</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> topologyContext      拓扑上下文</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> spoutOutputCollector 发射器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.conf = map;</span><br><span class="line">            <span class="keyword">this</span>.spoutOutputCollector = spoutOutputCollector;</span><br><span class="line">            <span class="keyword">this</span>.topologyContext = topologyContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 死循环方法，不断被调用处理元组。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.spoutOutputCollector.emit(<span class="keyword">new</span> Values(num++));</span><br><span class="line">            <span class="comment">//每隔一秒睡眠一次方便控制台观察输出</span></span><br><span class="line">            Utils.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 声明发射字段</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//fields中的参数与emit()中的Values()一一对应</span></span><br><span class="line">            outputFieldsDeclarer.declare(<span class="keyword">new</span> Fields(<span class="string">"num"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Map config;</span><br><span class="line">        <span class="keyword">private</span> TopologyContext topologyContext;</span><br><span class="line">        <span class="keyword">private</span> OutputCollector outputCollector;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map map, TopologyContext topologyContext, OutputCollector outputCollector)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.config = map;</span><br><span class="line">            <span class="keyword">this</span>.outputCollector = outputCollector;</span><br><span class="line">            <span class="keyword">this</span>.topologyContext = topologyContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只要spout中有数据产生，execute就会被不断调用。</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tuple</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">            Integer num = tuple.getIntegerByField(<span class="string">"num"</span>);</span><br><span class="line">            sum += num;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果不需要向外发射tuple，该方法就不需要实现。</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputFieldsDeclarer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer outputFieldsDeclarer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建执行方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nucc.channel.govern.demo.storm.topology;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.Config;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.TopologyBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 执行storm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhangchi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: zhangchi@nucc.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span>: 2018/5/5 23:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个topology</span></span><br><span class="line">        TopologyBuilder topologyBuilder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">        topologyBuilder.setSpout(<span class="string">"spoutName"</span>, <span class="keyword">new</span> StormTopology.Spout());</span><br><span class="line">        topologyBuilder.setBolt(<span class="string">"boltName"</span>, <span class="keyword">new</span> StormTopology.Bolt()).shuffleGrouping(<span class="string">"spoutName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个本地集群</span></span><br><span class="line">        LocalCluster localCluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">        String topologyName = <span class="keyword">new</span> StormTopology().getClass().getSimpleName();</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        localCluster.submitTopology(topologyName, config, topologyBuilder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接运行回报IRichSpout类找不到异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: org/apache/storm/topology/IRichSpout</span><br><span class="line">	at java.lang.Class.getDeclaredMethods0(Native Method)</span><br><span class="line">	at java.lang.Class.privateGetDeclaredMethods(Class.java:<span class="number">2701</span>)</span><br><span class="line">	at java.lang.Class.privateGetMethodRecursive(Class.java:<span class="number">3048</span>)</span><br><span class="line">	at java.lang.Class.getMethod0(Class.java:<span class="number">3018</span>)</span><br><span class="line">	at java.lang.Class.getMethod(Class.java:<span class="number">1784</span>)</span><br><span class="line">	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:<span class="number">544</span>)</span><br><span class="line">	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">526</span>)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.apache.storm.topology.IRichSpout</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">	... <span class="number">7</span> more</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">"main"</span></span><br></pre></td></tr></table></figure></p>
<p>需要把pom.xml中的scope注释掉</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果为:<br><img src="http://oy48q6kwm.bkt.clouddn.com/175f384b5f5abc26b816b032a715e025.png" alt="storm输出结果"></p>
<h3 id="集群模式运行"><a href="#集群模式运行" class="headerlink" title="集群模式运行"></a>集群模式运行</h3><h2 id="5、配置属性"><a href="#5、配置属性" class="headerlink" title="5、配置属性"></a>5、配置属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TopologyBuilder topologyBuilder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">org.apache.storm.generated.StormTopology topology = topologyBuilder.createTopology();</span><br><span class="line"></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.setNumWorkers(<span class="number">10</span>);</span><br><span class="line">config.setMaxSpoutPending(<span class="number">5000</span>);</span><br><span class="line">StormSubmitter.submitTopology(<span class="string">"TopologyName"</span>,config,topology);</span><br></pre></td></tr></table></figure>
<h2 id="6、整合kafka"><a href="#6、整合kafka" class="headerlink" title="6、整合kafka"></a>6、整合kafka</h2><p>###6.1、Spouts</p>
<p>提供核心的 Storm 和Trident 的spout实现，用来从Apache Kafka 版本消费数据. 支持 <a href="https://blog.csdn.net/liuxinghao/article/details/68944280" target="_blank" rel="noopener">Trident</a> 和 core Storm 的spout.对于这两种spout实现，我们使用BorkerHosts接口来跟踪Kafka broker host partition 映射关系，用KafkaConfig来控制Kafka 相关参数. </p>
<h3 id="6-2、BrokerHosts"><a href="#6-2、BrokerHosts" class="headerlink" title="6.2、BrokerHosts"></a>6.2、BrokerHosts</h3><p>为了初始化kafka spout/emitter，第一你需要构造一个 BrokerHosts 标记接口的实例。当前，我们支持以下两种实现方式. </p>
<ul>
<li><p>ZkHosts:</p>
<p>如果你想要动态的跟踪kafka broker partition映射关系，你应该使用ZkHosts。这个类使用Kafka Zookeeper实体跟踪brokerHost -&gt; 分区映射。你可以调用下面的方法得到一个实例<code>java public ZkHosts(String brokerZkStr, String brokerZkPath) public ZkHosts(String brokerZkStr)</code>ZkStr字符串个事是ip:port（例如：localhost:2181），brokerZkPath是存储所有topic和partition信息的zk根路径，默认情况下kafka使用/brokers路径。</p>
<p>默认情况下，broker-partition 映射关系60s秒从Zookeeper刷新一次.如果你想要改变这个时间，你需要设置 host.refreshFreqSecs 配置. </p>
</li>
<li><p>StaticHosts:</p>
<p>这是一种可替代的实现，broker-&gt;partition 信息是静态的.要构造这个类的实例，你需要先构造一个 GlobalPartitionInformation 的实例. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Broker brokerForPartition0 = <span class="keyword">new</span> Broker(<span class="string">"localhost"</span>);<span class="comment">//localhost:9092</span></span><br><span class="line">Broker brokerForPartition1 = <span class="keyword">new</span> Broker(<span class="string">"localhost"</span>, <span class="number">9092</span>);<span class="comment">//localhost:9092 but we specified the port explicitly</span></span><br><span class="line">Broker brokerForPartition2 = <span class="keyword">new</span> Broker(<span class="string">"localhost:9092"</span>);<span class="comment">//localhost:9092 specified as one string.</span></span><br><span class="line">GlobalPartitionInformation partitionInfo = <span class="keyword">new</span> GlobalPartitionInformation();</span><br><span class="line">partitionInfo.addPartition(<span class="number">0</span>, brokerForPartition0);<span class="comment">//mapping from partition 0 to brokerForPartition0</span></span><br><span class="line">partitionInfo.addPartition(<span class="number">1</span>, brokerForPartition1);<span class="comment">//mapping from partition 1 to brokerForPartition1</span></span><br><span class="line">partitionInfo.addPartition(<span class="number">2</span>, brokerForPartition2);<span class="comment">//mapping from partition 2 to brokerForPartition2</span></span><br><span class="line">StaticHosts hosts = <span class="keyword">new</span> StaticHosts(partitionInfo);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-3、KafkaConfig"><a href="#6-3、KafkaConfig" class="headerlink" title="6.3、KafkaConfig"></a>6.3、KafkaConfig</h3><p>  构造一个KafkaSpout的实例，第二件事情就是要实例化KafkaConfig。 <code>public KafkaConfig(BrokerHosts hosts, String topic)</code> <code>public KafkaConfig(BrokerHosts hosts, String topic, String clientId)</code> ,hosts可以通过多个BrokerHosts接口实现.topic 就是Kafka topic 的名称.可选择的ClientId就是当前消费的offset存储的zk的路径. </p>
<p>  Spoutconfig是KafkaConfig的扩展，它支持Zookeeper 连接信息的其他字段，并且可以控制KafkaSpout的行为.Zkroot就是用来存储消费者offset信息的根路径.id是唯一的用来标识spout.  <code>public SpoutConfig(BrokerHosts hosts, String topic, String zkRoot, String id);</code> <code>public SpoutConfig(BrokerHosts hosts, String topic, String id);</code> 除此之外，SpoutConfig包含下面这些字段，用来控制KafkaSpout的行为 </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置将当前Kafka偏移量保存到ZooKeeper的频率 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> stateUpdateIntervalMs = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重试失败消息的策略,使用ExponentialBackoffMsgRetryManager重试管理器。</span></span><br><span class="line"><span class="keyword">public</span> String failedMsgRetryManagerClass = ExponentialBackoffMsgRetryManager.class.getName();</span><br><span class="line"><span class="comment">//Exponential(指数函数)回退重试策略，在bolt调用OutputCollector.fail()之后，会调用ExponentialBackoffMsgRetryManager()尝试重新获取消息，前提是只有在使用了ExponentialBackoffMsgRetryManager 管理器的时候才会生效。</span></span><br><span class="line"><span class="comment">//连续重试之间的初试延迟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> retryInitialDelayMs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> retryDelayMultiplier = <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">//连续重试之间的最大延迟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> retryDelayMaxMs = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//如果retryLimit小于零，则将无限重试失败的消息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> retryLimit = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>  TridentKafkaConfig是KafkaConfig的另外一个扩展. TridentKafkaEmitter只接受TridentKafkaConfig作为参数.</p>
<p>  KafkaConfig类也有一些公共变量来控制你的应用程序的行为。以下是默认值：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kafka consumer 每次请求获取数据量的大小，默认1024 * 1024 = 1048576 = 1M</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> fetchSizeBytes = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//Consumer连接kafka server超时时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> socketTimeoutMs = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">//当服务器没有新消息时，消费者等待时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> fetchMaxWait = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">//Consumer端缓存大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> bufferSizeBytes = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//从Kafka中取出的byte[]，该如何反序列化</span></span><br><span class="line"><span class="keyword">public</span> MultiScheme scheme = <span class="keyword">new</span> RawMultiScheme();</span><br><span class="line"><span class="comment">//和startOffsetTime，一起用，默认情况下，为false，一旦startOffsetTime被设置，就要置为true。如果将forceFromStart(旧版本是ignoreZkOffsets）设置为true，则每次拓扑重新启动时，都会从开头读取消息。如果为false，则：第一次启动，从开头读取，之后的重启均是从offset中读取。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> forceFromStart = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// -2 从kafka头开始  -1 是从最新的开始 0 =无 从ZK开始</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> startOffsetTime = kafka.api.OffsetRequest.EarliestTime();</span><br><span class="line"><span class="comment">// 每次kafka会读取一批offset存放在list中，当zk offset比当前本地保存的commitOffse相减大于这个值时，重新设置commitOffset为当前zk offset，代码见PartitionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> maxOffsetBehind = Long.MAX_VALUE;</span><br><span class="line"><span class="comment">//如果所请求的offset对应的消息在Kafka中不存在，是否使用startOffsetTime</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> useStartOffsetTimeIfOffsetOutOfRange = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//多长时间统计一次metrics(度量)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> metricsTimeBucketSizeInSecs = <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>  <strong>MultiScheme：</strong>是一个用来规定 ByteBuffer 如何在Kafka 消费，并转换成一个 storm tuple.并且会控制 output field的命名 。默认的 <code>RawMultiScheme</code> 接受 <code>ByteBuffer</code> 参数，并返回一个 tuple.就是将ByteBuffer 转换成 <code>byte[]</code>.outPutField 的名称是 “bytes”。还有可替换的的实现，像 <code>SchemeAsMultiScheme</code> 和 <code>KeyValueSchemeAsMultiScheme</code>，他们会将 <code>ByteBuffer</code> 转换成 <code>String</code>.</p>
<p>  当然还有个<code>SchemeAsMultiScheme</code> 的扩展类，<code>MessageMetadataSchemeAsMultiScheme</code>，MessageMetadataSchemeAsMultiScheme有一个额外的反序列化方法，会接受ByteBuffer 信息，还会伴随着<code>Partition</code> 和 <code>offset</code> 信息.</p>
<p>###6.4、Failed message retry</p>
<p>  FailedMsgRetryManager是一个定义失败消息的重试策略的接口。默认实现是ExponentialBackoffMsgRetryManager，它在连续重试之间以指数延迟重试。要使用自定义实现，请将SpoutConfig.failedMsgRetryManagerClass设置为完整的实现类名称。 下面是接口： </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spout initialization can go here. This can be called multiple times during lifecycle of a worker. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(SpoutConfig spoutConfig, Map stormConf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message corresponding to offset has failed. This method is called only if retryFurther returns true for offset.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Long offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message corresponding to offset has been acked.  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acked</span><span class="params">(Long offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message corresponding to the offset, has been re-emitted and under transit.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retryStarted</span><span class="params">(Long offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset of message, which is to be re-emitted. Spout will fetch messages starting from this offset</span></span><br><span class="line"><span class="comment"> * and resend them, except completed messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Long <span class="title">nextFailedMessageToRetry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the message corresponding to the offset should be emitted NOW. False otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldReEmitMsg</span><span class="params">(Long offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spout will clean up the state for this offset if false is returned. If retryFurther is set to true,</span></span><br><span class="line"><span class="comment"> * spout will called failed(offset) in next call and acked(offset) otherwise </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retryFurther</span><span class="params">(Long offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clear any offsets before kafkaOffset. These offsets are no longer available in kafka.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Set&lt;Long&gt; <span class="title">clearOffsetsBefore</span><span class="params">(Long kafkaOffset)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="Version-incompatibility在1-0之前的Storm版本中，MultiScheme方法接受一个-byte-而不是-ByteBuffer。-MultScheme和相关的方案apis在版本1-0中被更改为接受ByteBuffer而不是byte-。这意味着，在1-0版及更高版本之前，1-0版的kafka-spouts将无法使用。在Storm-1-0及更高版本中运行拓扑时，必须确保storm-kafka版本至少为1-0。1-0之前的-topology-jar-必须重新和storm-kafka-1-0版本构建，以便在Storm-1-0及更高版本的群集中运行。"><a href="#Version-incompatibility在1-0之前的Storm版本中，MultiScheme方法接受一个-byte-而不是-ByteBuffer。-MultScheme和相关的方案apis在版本1-0中被更改为接受ByteBuffer而不是byte-。这意味着，在1-0版及更高版本之前，1-0版的kafka-spouts将无法使用。在Storm-1-0及更高版本中运行拓扑时，必须确保storm-kafka版本至少为1-0。1-0之前的-topology-jar-必须重新和storm-kafka-1-0版本构建，以便在Storm-1-0及更高版本的群集中运行。" class="headerlink" title="Version incompatibility在1.0之前的Storm版本中，MultiScheme方法接受一个 byte [] 而不是 ByteBuffer。 MultScheme和相关的方案apis在版本1.0中被更改为接受ByteBuffer而不是byte []。这意味着，在1.0版及更高版本之前，1.0版的kafka spouts将无法使用。在Storm 1.0及更高版本中运行拓扑时，必须确保storm-kafka版本至少为1.0。1.0之前的 topology jar 必须重新和storm-kafka 1.0版本构建，以便在Storm 1.0及更高版本的群集中运行。"></a>Version incompatibility在1.0之前的Storm版本中，MultiScheme方法接受一个 <code>byte []</code> 而不是 <code>ByteBuffer</code>。 MultScheme和相关的方案apis在版本1.0中被更改为接受ByteBuffer而不是byte []。这意味着，在1.0版及更高版本之前，1.0版的kafka spouts将无法使用。在Storm 1.0及更高版本中运行拓扑时，必须确保storm-kafka版本至少为1.0。1.0之前的 topology jar 必须重新和storm-kafka 1.0版本构建，以便在Storm 1.0及更高版本的群集中运行。</h4></blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaBrokerHosts hosts = <span class="keyword">new</span> ZkHosts(zkConnString);</span><br><span class="line">SpoutConfig spoutConfig = <span class="keyword">new</span> SpoutConfig(hosts, topicName, <span class="string">"/"</span> + topicName, UUID.randomUUID().toString());</span><br><span class="line">spoutConfig.scheme = <span class="keyword">new</span> SchemeAsMultiScheme(<span class="keyword">new</span> StringScheme());</span><br><span class="line">KafkaSpout kafkaSpout = <span class="keyword">new</span> KafkaSpout(spoutConfig);</span><br></pre></td></tr></table></figure>
<h4 id="Trident-Spout"><a href="#Trident-Spout" class="headerlink" title="Trident Spout"></a>Trident Spout</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TridentTopology topology = <span class="keyword">new</span> TridentTopology();</span><br><span class="line">BrokerHosts zk = <span class="keyword">new</span> ZkHosts(<span class="string">"localhost"</span>);</span><br><span class="line">TridentKafkaConfig spoutConf = <span class="keyword">new</span> TridentKafkaConfig(zk, <span class="string">"test-topic"</span>);</span><br><span class="line">spoutConf.scheme = <span class="keyword">new</span> SchemeAsMultiScheme(<span class="keyword">new</span> StringScheme());</span><br><span class="line">OpaqueTridentKafkaSpout spout = <span class="keyword">new</span> OpaqueTridentKafkaSpout(spoutConf);</span><br></pre></td></tr></table></figure>
<h3 id="6-5、偏移量处理"><a href="#6-5、偏移量处理" class="headerlink" title="6.5、偏移量处理"></a>6.5、偏移量处理</h3><pre><code>KafkaSpout如何存储Kafka主题的偏移量并在发生故障时恢复，如上面的KafkaConfig属性所示，您可以通过设置 `KafkaConfig.startOffsetTime` 来控制从Kafka topic 的哪个端口开始读取，如下所示： 
</code></pre><ul>
<li>kafka.api.OffsetRequest.EarliestTime()：从topic 初始位置读取消息 (例如，从最老的那个消息开始) </li>
<li>kafka.api.OffsetRequest.LatestTime()：从topic尾部开始读取消息 (例如，新写入topic的信息) </li>
<li><p>一个Unix时间戳，从当前 epoch 开始.（例如，可以通过System.currentTimeMillis(）），具体的可以查看Kafka FAQ中的 <a href="https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-HowdoIaccuratelygetoffsetsofmessagesforacertaintimestampusingOffsetRequest?" target="_blank" rel="noopener">How do I accurately get offsets of messages for a certain timestamp using OffsetRequest?</a> .</p>
<p>   当topology（拓扑）运行Kafka Spout ，并跟踪读取和发送的offset，并将状态信息存储到zk path <code>SpoutConfig.zkRoot+ &quot;/&quot; + SpoutConfig.id</code>.在故障的情况下，它会从ZooKeeper的最后一次写入偏移中恢复。 </p>
</li>
</ul>
<blockquote>
<p><strong>Important:</strong> 新部署topology（拓扑）时，请确保<code>SpoutConfig.zkRoot</code>和<code>SpoutConfig.id</code>的设置未被修改， 否则spout将无法从ZooKeeper中读取以前的消费者状态信息（即偏移量）导致意外的行为和/或数据丢失，具体取决于您的用例。 </p>
</blockquote>
<p>这意味着当topology（拓扑）运行一旦设置<code>KafkaConfig.startOffsetTime</code>将不会对 topology（拓扑）的后续运行产生影响， 因为现在 topology（拓扑）将依赖于ZooKeeper中的消费者状态信息（偏移量）来确定从哪里开始（更多准确地：简历）阅读。 如果要强制该端口忽略存储在ZooKeeper中的任何消费者状态信息，则应将参数<code>KafkaConfig.forceFromStart</code>设置为true。如果为<code>true</code>， 则如上所述，spout 将始终从<code>KafkaConfig.startOffsetTime</code>定义的偏移量开始读取。 </p>
<p>##7、Bolts</p>
<p><em>bolts</em>是一个Storm集群中的关键组件 ，它把元组作为输入，然后产生新的元组作为输出。实现一个<em>bolt</em>时，通常需要实现<strong>IRichBolt</strong>接口。<em>Bolts</em>对象由客户端机器创建，序列化为拓扑，并提交给集群中的主机。然后集群启动工人进程反序列化<em>bolt</em>，调用<strong>prepare</strong>，最后开始处理元组。 要创建一个bolt对象，它通过构造器参数初始化成员属性，<em>bolt</em>被提交到集群时，这些属性值会随着一起序列化。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nucc.channel.govern.storm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map config;</span><br><span class="line">    <span class="keyword">private</span> TopologyContext topologyContext;</span><br><span class="line">    <span class="keyword">private</span> OutputCollector outputCollector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stormConf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = stormConf;</span><br><span class="line">        <span class="keyword">this</span>.outputCollector = collector;</span><br><span class="line">        <span class="keyword">this</span>.topologyContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要spout中有数据产生，execute就会被不断调用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">        String logLine = input.getString(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputCollector.emit(Arrays.asList(<span class="string">"label"</span>, parser.parse(logLine)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"Failing parse and ignore audit log &#123;&#125; "</span>, logLine, ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            outputCollector.ack(input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  为bolt声明输出模式</span></span><br><span class="line"><span class="comment">     * 如果不需要向外发射tuple，该方法就不需要实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> declarer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"label"</span>, <span class="string">"message"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓扑是一个树型结构，消息（元组）穿过其中一条或多条分支。树上的每个节点都会调用<strong>ack(tuple)</strong>或<strong>fail(tuple)</strong>，Storm因此知道一条消息是否失败了，并通知那个/那些制造了这些消息的<em>spout(s)</em>。既然一个Storm拓扑运行在高度并行化的环境里，跟踪始发<em>spout</em>实例的最好方法就是在消息元组内包含一个始发spout引用。这一技巧称做<strong>锚定</strong>。</p>
<p>锚定发生在调用<strong>collector.emit()</strong>时。正如前面提到的，Storm可以沿着元组追踪到始发<em>spout</em>。<strong>collector.ack(tuple)</strong>和<strong>collector.fail(tuple)</strong>会告知spout每条消息都发生了什么。当树上的每条消息都已被处理了，Storm就认为来自<em>spout</em>的元组被全面的处理了。如果一个元组没有在设置的超时时间内完成对消息树的处理，就认为这个元组处理失败。默认超时时间为30秒。 </p>
<h3 id="7-1、多数据流"><a href="#7-1、多数据流" class="headerlink" title="7.1、多数据流"></a>7.1、多数据流</h3><p>一个<em>bolt</em>可以使用<strong>emit(streamId, tuple)</strong>把元组分发到多个流，其中参数<strong>streamId</strong>是一个用来标识流的字符串。然后，你可以在<strong>TopologyBuilder</strong>决定由哪个流订阅它。 </p>
<h3 id="7-2、多锚定"><a href="#7-2、多锚定" class="headerlink" title="7.2、多锚定"></a>7.2、多锚定</h3><p>为了用<em>bolt</em>连接或聚合数据流，你需要借助内存缓冲元组。为了在这一场景下确保消息完成，你不得不把流锚定到多个元组上。可以向<strong>emit</strong>方法传入一个元组列表来达成目的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">List anchors = <span class="keyword">new</span> ArrayList();</span><br><span class="line">anchors.add(tuple1);</span><br><span class="line">anchors.add(tuple2);</span><br><span class="line">collector.emit(anchors, values);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过这种方式，bolt在任意时刻调用<strong>ack</strong>或<strong>fail</strong>方法，都会通知消息树，而且由于流锚定了多个元组，所有相关的<em>spout</em>都会收到通知。 </p>
<h3 id="7-3、使用IBasicBolt自动确认"><a href="#7-3、使用IBasicBolt自动确认" class="headerlink" title="7.3、使用IBasicBolt自动确认"></a>7.3、使用IBasicBolt自动确认</h3><p>你可能已经注意到了，在许多情况下都需要消息确认。简单起见，Storm提供了另一个用来实现<em>bolt</em>的接口，<strong>IBasicBolt</strong>。对于该接口的实现类的对象，会在执行<strong>execute</strong>方法之后自动调用<strong>ack</strong>方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">        String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word : sentence.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            collector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NOTE:</strong>分发消息的BasicOutputCollector自动锚定到作为参数传入的元组。 </p>
<h2 id="8、Tuple传递模式"><a href="#8、Tuple传递模式" class="headerlink" title="8、Tuple传递模式"></a>8、Tuple传递模式</h2><p>所谓的grouping策略就是在Spout与Bolt、Bolt与Bolt之间传递Tuple的方式。总共有七种方式： </p>
<ul>
<li><p>shuffleGrouping ：随机分组。Task中的数据随机分批，可以保证同一级Bolt上的每个Task处理的Tuple数量一致。他能实现较好的负载均衡恒。</p>
<p> <img src="C:\Users\zhangchi\Pictures\Saved Pictures\1534484566974.png" alt="1534484566974"></p>
</li>
<li><p>fieldsGrouping ：按照字段分组，在这里即是同一个单词只能发送给一个Bolt 。根据Tuple中的某一个Filed或者多个Filed的值来划分。比如Stream根据user-id的值来分组，具有相同user-id值的Tuple会被分到相同的Task中(具有不同user-id值的Tuple可能会被分发到其他Task中。比如user-id为1的Tuple都会分发给Task1，user-id为2的Tuple可能在Task1上也可能在Task2上，但是同时只能在一个Task上)。</p>
<p> <img src="C:\Users\zhangchi\AppData\Local\Temp\1534486378370.png" alt="1534486378370"></p>
</li>
<li><p>allGrouping ：广播发送，所有的Tuple会分发到所有的Task上。</p>
<p> <img src="C:\Users\zhangchi\Pictures\Saved Pictures\1534486615053.png" alt="1534486615053"> </p>
</li>
<li><p>globalGrouping ：全局分组，整个Stream会选择一个Task作为分发的目的地，通常会将Tuple分配到task id值最低的task里面 </p>
<p> <img src="C:\Users\zhangchi\AppData\Local\Temp\1534486864083.png" alt="1534486864083"></p>
</li>
<li><p>noneGrouping：随机分派，Stream不关心将Tuple分发到哪个Task上，目前等同于Shuffle分组。</p>
</li>
<li><p>directGrouping：直接分组，指定Tuple与Bolt的对应发送关系 。也就是产生数据的spout/bolt自己明确决定这个Tupl被BOlt的哪些Task所消费。如果使用Direct分组，需要使用OutputCollector的emitDirect()方法来实现。</p>
</li>
<li><p>Local or shuffle Grouping：如果目标Bolt中的一个或者多个Task和当前生产数据的Task再同一个worker进程中，那么就走内部的线程间通信，将Tuple直接发给在当前Worker进程中的目的Task。否则，同Shuffle分组。</p>
</li>
<li><p>customGrouping：自定义group</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/storm/" rel="tag"># storm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/12/druid/" rel="next" title="druid">
                <i class="fa fa-chevron-left"></i> druid
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/12/books/" rel="prev" title="books">
                books <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://example.com/avatar.png"
                alt="张舒歌" />
            
              <p class="site-author-name" itemprop="name">张舒歌</p>
              <p class="site-description motion-element" itemprop="description">天道酬勤、厚德载物</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Storm"><span class="nav-number">1.</span> <span class="nav-text">Storm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、基本概念"><span class="nav-number">1.1.</span> <span class="nav-text">1、基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Storm组件"><span class="nav-number">1.2.</span> <span class="nav-text">2、Storm组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Topology（拓扑）"><span class="nav-number">1.2.1.</span> <span class="nav-text">Topology（拓扑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream（流）"><span class="nav-number">1.2.2.</span> <span class="nav-text">Stream（流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tuple"><span class="nav-number">1.2.3.</span> <span class="nav-text">Tuple</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、安装"><span class="nav-number">1.3.</span> <span class="nav-text">3、安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载安装包上传至服务器http-storm-apache-org-downloads-html"><span class="nav-number">1.3.1.</span> <span class="nav-text">下载安装包上传至服务器http://storm.apache.org/downloads.html</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配好资源"><span class="nav-number">1.3.2.</span> <span class="nav-text">分配好资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动服务"><span class="nav-number">1.3.3.</span> <span class="nav-text">启动服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、开发"><span class="nav-number">1.4.</span> <span class="nav-text">4、开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地模式"><span class="nav-number">1.4.1.</span> <span class="nav-text">本地模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群模式运行"><span class="nav-number">1.4.2.</span> <span class="nav-text">集群模式运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、配置属性"><span class="nav-number">1.5.</span> <span class="nav-text">5、配置属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、整合kafka"><span class="nav-number">1.6.</span> <span class="nav-text">6、整合kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2、BrokerHosts"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.2、BrokerHosts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3、KafkaConfig"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.3、KafkaConfig</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Version-incompatibility在1-0之前的Storm版本中，MultiScheme方法接受一个-byte-而不是-ByteBuffer。-MultScheme和相关的方案apis在版本1-0中被更改为接受ByteBuffer而不是byte-。这意味着，在1-0版及更高版本之前，1-0版的kafka-spouts将无法使用。在Storm-1-0及更高版本中运行拓扑时，必须确保storm-kafka版本至少为1-0。1-0之前的-topology-jar-必须重新和storm-kafka-1-0版本构建，以便在Storm-1-0及更高版本的群集中运行。"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Version incompatibility在1.0之前的Storm版本中，MultiScheme方法接受一个 byte [] 而不是 ByteBuffer。 MultScheme和相关的方案apis在版本1.0中被更改为接受ByteBuffer而不是byte []。这意味着，在1.0版及更高版本之前，1.0版的kafka spouts将无法使用。在Storm 1.0及更高版本中运行拓扑时，必须确保storm-kafka版本至少为1.0。1.0之前的 topology jar 必须重新和storm-kafka 1.0版本构建，以便在Storm 1.0及更高版本的群集中运行。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trident-Spout"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Trident Spout</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5、偏移量处理"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.5、偏移量处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1、多数据流"><span class="nav-number">1.6.4.</span> <span class="nav-text">7.1、多数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2、多锚定"><span class="nav-number">1.6.5.</span> <span class="nav-text">7.2、多锚定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3、使用IBasicBolt自动确认"><span class="nav-number">1.6.6.</span> <span class="nav-text">7.3、使用IBasicBolt自动确认</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、Tuple传递模式"><span class="nav-number">1.7.</span> <span class="nav-text">8、Tuple传递模式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张舒歌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
